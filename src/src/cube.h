// one big bad include file for the whole engine... nasty!

// Portions copyright (c) 2005 Intel Corporation, all rights reserved 

#include "tools.h"			

enum                            // block types, order matters!
{
    SOLID = 0,                  // entirely solid cube [only specifies wtex]
    CORNER,                     // half full corner of a wall
    FHF,                        // floor heightfield using neighbour vdelta values
    CHF,                        // idem ceiling
    SPACE,                      // entirely empty cube
    SEMISOLID,                  // generated by mipmapping
    MAXTYPE
};
 
struct sqr
{
    uchar type;                 // one of the above
    char floor, ceil;           // height, in cubes
    uchar wtex, ftex, ctex;     // wall/floor/ceil texture ids
    uchar r, g, b;              // light value at upper left vertex
    uchar vdelta;               // vertex delta, used for heightfield cubes
    char defer;                 // used in mipmapping, when true this cube is not a perfect mip
    char occluded;              // true when occluded
    uchar utex;                 // upper wall tex id
    uchar tag;                  // used by triggers
};

enum                            // hardcoded texture numbers
{
    DEFAULT_SKY = 0,
    DEFAULT_LIQUID,
    DEFAULT_WALL,
    DEFAULT_FLOOR,
    DEFAULT_CEIL
};

enum                            // static entity types
{
    NOTUSED = 0,                // entity slot not in use in map
    LIGHT,                      // lightsource, attr1 = radius, attr2 = intensity
    PLAYERSTART,                // attr1 = angle
    I_SHELLS, I_BULLETS, I_ROCKETS, I_ROUNDS,
    I_HEALTH, I_BOOST,
    I_GREENARMOUR, I_YELLOWARMOUR,
    I_QUAD,
    TELEPORT,                   // attr1 = idx
    TELEDEST,                   // attr1 = angle, attr2 = idx
    MAPMODEL,                   // attr1 = angle, attr2 = idx
    MONSTER,                    // attr1 = angle, attr2 = monstertype
    CARROT,                     // attr1 = tag, attr2 = type
    JUMPPAD,                    // attr1 = zpush, attr2 = ypush, attr3 = xpush
    MAXENTTYPES
};

struct persistent_entity        // map entity
{
    short x, y, z;              // cube aligned position
    short attr1;
    uchar type;                 // type is one of the above
    uchar attr2, attr3, attr4;        
};

struct entity : public persistent_entity    
{
    bool spawned;               // the only dynamic state of a map entity
};

#define MAPVERSION 5            // bump if map format changes, see worldio.cpp

struct header                   // map file format header
{
    char head[4];               // "CUBE"
    int version;                // any >8bit quantity is a little indian
    int headersize;             // sizeof(header)
    int sfactor;                // in bits
    int numents;
    char maptitle[128];
    uchar texlists[3][256];
    int waterlevel;
    int reserved[15];
};

#define SWS(w,x,y,s) (&(w)[(y)*(s)+(x)])
#define SW(w,x,y) SWS(w,x,y,ssize)
#define S(x,y) SW(world,x,y)            // convenient lookup of a lowest mip cube
#define SMALLEST_FACTOR 6               // determines number of mips there can be
#define DEFAULT_FACTOR 8
#define LARGEST_FACTOR 11               // 10 is already insane
#define SOLID(x) ((x)->type==SOLID)
#define MINBORD 2                       // 2 cubes from the edge of the world are always solid
#define OUTBORD(x,y) ((x)<MINBORD || (y)<MINBORD || (x)>=ssize-MINBORD || (y)>=ssize-MINBORD)

struct vec { float x, y, z; };
struct block { int x, y, xs, ys; };
struct mapmodelinfo { int rad, h, zoff, snap; char *name; };

enum { GUN_FIST = 0, GUN_SG, GUN_CG, GUN_RL, GUN_RIFLE, GUN_FIREBALL, GUN_ICEBALL, GUN_SLIMEBALL, GUN_BITE, NUMGUNS };

struct dynent                           // players & monsters
{
    vec o, vel;                         // origin, velocity
    float yaw, pitch, roll;             // used as vec in one place
    float maxspeed;                     // cubes per second, 24 for player
    bool outsidemap;                    // from his eyes
    bool inwater;
    bool onfloor, jumpnext;
    int move, strafe;
    bool k_left, k_right, k_up, k_down; // see input code  
    int timeinair;                      // used for fake gravity
    float radius, eyeheight, aboveeye;  // bounding box size
    int lastupdate, plag, ping;
    int lifesequence;                   // sequence id for each respawn, used in damage test
    int state;                          // one of CS_* below
    int frags;
    int health, armour, armourtype, quadmillis;
    int gunselect, gunwait;
    int lastaction, lastattackgun, lastmove;
    bool attacking;
    int ammo[NUMGUNS];
    int monsterstate;                   // one of M_* below, M_NONE means human
    int mtype;                          // see monster.cpp
    dynent *enemy;                      // monster wants to kill this entity
    float targetyaw;                    // monster wants to look in this direction
    bool blocked, moving;               // used by physics to signal ai
    int trigger;                        // millis at which transition to another monsterstate takes place
    vec attacktarget;                   // delayed attacks
    int anger;                          // how many times already hit by fellow monster
    string name, team;
};

#define SAVEGAMEVERSION 4               // bump if dynent/netprotocol changes or any other savegame/demo data

enum { A_BLUE, A_GREEN, A_YELLOW };     // armour types... take 20/40/60 % off
enum { M_NONE = 0, M_SEARCH, M_HOME, M_ATTACKING, M_PAIN, M_SLEEP, M_AIMING };  // monster states

#define MAXCLIENTS 256                  // in a multiplayer game, can be arbitrarily changed
#define MAXTRANS 5000                   // max amount of data to swallow in 1 go
#define CUBE_SERVER_PORT 28765
#define CUBE_SERVINFO_PORT 28766
#define PROTOCOL_VERSION 121            // bump when protocol changes

// network messages codes, c2s, c2c, s2c
enum
{
    SV_INITS2C = 0, SV_INITC2S, SV_POS, SV_TEXT, SV_SOUND, SV_CDIS,
    SV_DIED, SV_DAMAGE, SV_SHOT, SV_FRAGS,
    SV_TIMEUP, SV_EDITENT, SV_MAPRELOAD, SV_ITEMACC,
    SV_MAPCHANGE, SV_ITEMSPAWN, SV_ITEMPICKUP, SV_DENIED,
    SV_PING, SV_PONG, SV_CLIENTPING, SV_GAMEMODE,
    SV_EDITH, SV_EDITT, SV_EDITS, SV_EDITD, SV_EDITE,
    SV_SENDMAP, SV_RECVMAP, SV_SERVMSG, SV_ITEMLIST,
    SV_EXT,
};     

enum { CS_ALIVE = 0, CS_DEAD, CS_LAGGED, CS_EDITING };

// hardcoded sounds, defined in sounds.cfg
enum
{
    S_JUMP = 0, S_LAND, S_RIFLE, S_PUNCH1, S_SG, S_CG,
    S_RLFIRE, S_RLHIT, S_WEAPLOAD, S_ITEMAMMO, S_ITEMHEALTH,
    S_ITEMARMOUR, S_ITEMPUP, S_ITEMSPAWN, S_TELEPORT, S_NOAMMO, S_PUPOUT,
    S_PAIN1, S_PAIN2, S_PAIN3, S_PAIN4, S_PAIN5, S_PAIN6,
    S_DIE1, S_DIE2,
    S_FLAUNCH, S_FEXPLODE,
    S_SPLASH1, S_SPLASH2,
    S_GRUNT1, S_GRUNT2, S_RUMBLE,
    S_PAINO,
    S_PAINR, S_DEATHR, 
    S_PAINE, S_DEATHE, 
    S_PAINS, S_DEATHS,
    S_PAINB, S_DEATHB, 
    S_PAINP, S_PIGGR2, 
    S_PAINH, S_DEATHH,
    S_PAIND, S_DEATHD,
    S_PIGR1, S_ICEBALL, S_SLIMEBALL,
    S_JUMPPAD,
};

typedef vector<dynent *> dvector;
typedef vector<char *> cvector;
typedef vector<int> ivector;

// globals ooh naughty

extern sqr *world, *wmip[];             // map data, the mips are sequential 2D arrays in memory
extern header hdr;                      // current map header
extern int sfactor, ssize;              // ssize = 2^sfactor
extern int cubicsize, mipsize;          // cubicsize = ssize^2
extern dynent *player1;                 // special client ent that receives input and acts as camera
extern dvector players;                 // all the other clients (in multiplayer)
extern bool editmode;
extern vector<entity> ents;             // map entities
extern vec worldpos;                    // current target of the crosshair in the world
extern int lastmillis;                  // last time
extern int curtime;                     // current frame time
extern int gamemode, nextmode;
extern int xtraverts;
extern bool demoplayback;

#define DMF 16.0f 
#define DAF 1.0f 
#define DVF 100.0f

#define VIRTW 2400                      // virtual screen size for text & HUD
#define VIRTH 1800
#define FONTH 64
#define PIXELTAB (VIRTW/12)

// Begin Intel Corporation code
#ifdef _WIN32_WCE
// PI and 2PI in fixed point
#define PI_FX 0x0003243F
#define TWOPI_FX 0x0006487E
#endif /* _WIN32_WCE */
// End Intel Corporation code

#define PI  (3.1415927f)
#define PI2 (2*PI)

// simplistic vector ops
#define dotprod(u,v) ((u).x * (v).x + (u).y * (v).y + (u).z * (v).z)
#define vmul(u,f)    { (u).x *= (f); (u).y *= (f); (u).z *= (f); }
#define vdiv(u,f)    { (u).x /= (f); (u).y /= (f); (u).z /= (f); }
#define vadd(u,v)    { (u).x += (v).x; (u).y += (v).y; (u).z += (v).z; };
#define vsub(u,v)    { (u).x -= (v).x; (u).y -= (v).y; (u).z -= (v).z; };
#define vdist(d,v,e,s) vec v = s; vsub(v,e); float d = (float)sqrt(dotprod(v,v));
#define vreject(v,u,max) ((v).x>(u).x+(max) || (v).x<(u).x-(max) || (v).y>(u).y+(max) || (v).y<(u).y-(max))
#define vlinterp(v,f,u,g) { (v).x = (v).x*f+(u).x*g; (v).y = (v).y*f+(u).y*g; (v).z = (v).z*f+(u).z*g; }

#define sgetstr() { char *t = text; do { *t = getint(p); } while(*t++); }   // used by networking

#define m_noitems     (gamemode>=4)
#define m_noitemsrail (gamemode<=5)
#define m_arena       (gamemode>=8)
#define m_tarena      (gamemode>=10)
#define m_teammode    (gamemode&1 && gamemode>2)
#define m_sp          (gamemode<0)
#define m_dmsp        (gamemode==-1)
#define m_classicsp   (gamemode==-2)
#define isteam(a,b)   (m_teammode && strcmp(a, b)==0)

enum    // function signatures for script functions, see command.cpp
{
    ARG_1INT, ARG_2INT, ARG_3INT, ARG_4INT,
    ARG_NONE,
    ARG_1STR, ARG_2STR, ARG_3STR, ARG_5STR,
    ARG_DOWN, ARG_DWN1,
    ARG_1EXP, ARG_2EXP,
    ARG_1EST, ARG_2EST,
    ARG_VARI
}; 

// nasty macros for registering script functions, abuses globals to avoid excessive infrastructure
#define COMMANDN(name, fun, nargs) static bool __dummy_##fun = addcommand(#name, (void (*)())fun, nargs)
#define COMMAND(name, nargs) COMMANDN(name, name, nargs)
#define VAR(name, min, cur, max) int name = variable(#name, min, cur, max, &name, NULL)
#define VARF(name, min, cur, max, body) void var_##name(); static int name = variable(#name, min, cur, max, &name, var_##name); void var_##name() { body; }

#define ATOI(s) strtol(s, NULL, 0)		// supports hexadecimal numbers

#if defined(WIN32) || defined(_WIN32_WCE)
	#define WIN32_LEAN_AND_MEAN
	#include "windows.h"
	#define _WINDOWS
	#define ZLIB_DLL
#else
	#include <dlfcn.h>
#endif

#include <time.h>

#ifdef _WIN32_WCE // Begin Intel Corporation code
	// include OpenGL ES and GAPI headers
	#include <gles/gl.h>
	#include <gx.h>
#else // End Intel Corporation code
	#include <GL/gl.h>
	#include <GL/glu.h>
	#include <GL/glext.h>
#endif /* _WIN32_WCE */

#include <SDL.h>
#include <SDL_image.h>

#include <enet/enet.h>

#include <zlib.h>

#include "protos.h"				// external function decls

// vertex array format
#ifdef _WIN32_WCE // Begin Intel Corporation code
// fixed point storage of vertices, much faster than last second conversion
struct vertex { GLfixed u, v, x, y, z; uchar r, g, b, a; };
#else // End Intel Corporation code
struct vertex { float u, v, x, y, z; uchar r, g, b, a; }; 
#endif /* _WIN32_WCE */

#ifdef _WIN32_WCE // Begin Intel Corporation code

// global functions
extern const GLfixed divtable[128][128];
extern void reloadtextures();
extern void reloadmodeltextures();
extern BOOL ResetPocketPC();
extern void quit();

// Often used fixed numbers
#define HALF_FX 0x00008000
#define ONE_FX 0x00010000
#define TWO_FX 0x00020000
#define THREE_FX 0x00030000
#define FOUR_FX 0x00040000
#define SIXTEEN_FX 0x00100000
#define ONETWENTYEIGHT_FX 0x00800000

// fixed conversion routines and absolute value
#define _fixed_shift 16 // our fixed point is 16.16, used throughout
const float FXFACTOR = (1.0f/65536.0f);
const float FXINV = 65536.0f;

__inline GLfixed f2x(float f) { return (GLfixed)((f)*FXINV);}
__inline float x2f(GLfixed x) { return (float)(x)*FXFACTOR; }
__inline GLfixed i2x(int i) { return (i)<<_fixed_shift; }
__inline int x2i(GLfixed x) { return int(x)>>_fixed_shift; }
__inline GLfixed absfx(GLfixed x) { return (x<0) ? -x : x; }

// multiply two fixed values
__inline GLfixed MulFX(GLfixed x, GLfixed y)
{
	__int64 r = ((__int64)x) * y;
	return (GLint)(r >> 16);
}

// divide two fixed values with optional table lookup for speed and less precision
__forceinline GLfixed DivFX(const GLfixed x, const GLfixed y, bool fast = false) 
{
	// check boundaries and fast directive
	if(fast && absfx(x) < ONETWENTYEIGHT_FX && absfx(y) < ONETWENTYEIGHT_FX)
	{
		// positive x
		if(x >= HALF_FX)
		{
			// positive y
			if(y >= HALF_FX)
				return divtable[x2i(x+HALF_FX)-1][x2i(y+HALF_FX)-1];
			// negative y
			else
				return -divtable[x2i(x+HALF_FX)-1][x2i(-y+HALF_FX)-1];
		}
		// negative x
		else
		{
			// positive y
			if(y >= HALF_FX)
				return -divtable[x2i(-x+HALF_FX)-1][x2i(y+HALF_FX)-1];
			// negative y
			else
				return divtable[x2i(-x+HALF_FX)-1][x2i(-y+HALF_FX)-1];
		}
	}
	else
		// regular slow and precise divide
		return (GLint)((((__int64)x)<<16)/(y));
}

// fixed point sin
__inline GLfixed SinFX(const GLfixed x)
{
	return f2x((float)sin(x2f(x)));
}

// fixed point cosine
__inline GLfixed CosFX(const GLfixed x)
{
	return f2x((float)cos(x2f(x)));
}

// fixed point tangent
__inline GLfixed TanFX(const GLfixed x)
{
	return f2x((float)tan(x2f(x)));
}

// Rewrite of OpenGL ES transform stack to work around the QueryMatrixOES 
// function that is missing in some implementations

extern GLfixed modelview[16];
extern GLfixed projection[16];
extern vector<GLfixed *>modelstack;
extern vector<GLfixed *>projstack;

// intended to emulate glLoadIdentity
__inline void identity(GLfixed *curMtrx) 
{
    curMtrx[0] = ONE_FX;  curMtrx[4] = 0;		curMtrx[8] = 0;			curMtrx[12] = 0;
    curMtrx[1] = 0;		  curMtrx[5] = ONE_FX;  curMtrx[9] = 0;			curMtrx[13] = 0;
    curMtrx[2] = 0;		  curMtrx[6] = 0;		curMtrx[10] = ONE_FX;   curMtrx[14] = 0;
    curMtrx[3] = 0;		  curMtrx[7] = 0;		curMtrx[11] = 0;		curMtrx[15] = ONE_FX;
	
	glLoadIdentity();
}

// push a projection matrix onto projstack
__inline void pushProjMatrix()
{
	GLfixed *toAdd = new GLfixed[16];

	for(int i = 0; i < 16; i++)
		toAdd[i] = projection[i];

	projstack.add(toAdd);
}

// push a modelview matrix onto modelstack
__inline void pushModelMatrix()
{
	GLfixed *toAdd = new GLfixed[16];

	for(int i = 0; i < 16; i++)
		toAdd[i] = modelview[i];

	modelstack.add(toAdd);
}

// pop the top projection matrix from projstack
__inline void popProjMatrix()
{
	// if empty, top is always identity
	if(projstack.length() == 0)
		identity(projection);
	else
	{
		GLfixed *temp = projstack.pop();

		for(int i = 0; i < 16; i++)
			projection[i] = temp[i];

		delete temp;

		// load the popped matrix into OpenGL, assumes state is set correctly
		glLoadMatrixx(projection);
	}
}

// pop the top modelview matrix from modelstack
__inline void popModelMatrix()
{
	// if empty, top is always identity
	if(modelstack.length() == 0)
		identity(modelview);
	else
	{
		GLfixed *temp = modelstack.pop();

		for(int i = 0; i < 16; i++)
			modelview[i] = temp[i];

		delete temp;

		// load the popped matrix into OpenGL, assumes state is set correctly
		glLoadMatrixx(modelview);
	}
}

// 4x4 fixed point matrix multiply
__inline void matrixMultiply(const GLfixed *in1, const GLfixed *in2, GLfixed *out)
{
	if(!out || !in1 || !in2) return;

	out[0] = MulFX(in1[0],in2[0]) + MulFX(in1[1],in2[4]) + MulFX(in1[2],in2[8]) + MulFX(in1[3],in2[12]);    
	out[1] = MulFX(in1[0],in2[1]) + MulFX(in1[1],in2[5]) + MulFX(in1[2],in2[9]) + MulFX(in1[3],in2[13]);    
	out[2] = MulFX(in1[0],in2[2]) + MulFX(in1[1],in2[6]) + MulFX(in1[2],in2[10]) + MulFX(in1[3],in2[14]);    
	out[3] = MulFX(in1[0],in2[3]) + MulFX(in1[1],in2[7]) + MulFX(in1[2],in2[11]) + MulFX(in1[3],in2[15]);    
	out[4] = MulFX(in1[4],in2[0]) + MulFX(in1[5],in2[4]) + MulFX(in1[6],in2[8]) + MulFX(in1[7],in2[12]);    
	out[5] = MulFX(in1[4],in2[1]) + MulFX(in1[5],in2[5]) + MulFX(in1[6],in2[9]) + MulFX(in1[7],in2[13]);    
	out[6] = MulFX(in1[4],in2[2]) + MulFX(in1[5],in2[6]) + MulFX(in1[6],in2[10]) + MulFX(in1[7],in2[14]);    
	out[7] = MulFX(in1[4],in2[3]) + MulFX(in1[5],in2[7]) + MulFX(in1[6],in2[11]) + MulFX(in1[7],in2[15]);    
	out[8] = MulFX(in1[8],in2[0]) + MulFX(in1[9],in2[4]) + MulFX(in1[10],in2[8]) + MulFX(in1[11],in2[12]);    
	out[9] = MulFX(in1[8],in2[1]) + MulFX(in1[9],in2[5]) + MulFX(in1[10],in2[9]) + MulFX(in1[11],in2[13]);    
	out[10] = MulFX(in1[8],in2[2]) + MulFX(in1[9],in2[6]) + MulFX(in1[10],in2[10]) + MulFX(in1[11],in2[14]);    
	out[11] = MulFX(in1[8],in2[3]) + MulFX(in1[9],in2[7]) + MulFX(in1[10],in2[11]) + MulFX(in1[11],in2[15]);    
	out[12] = MulFX(in1[12],in2[0]) + MulFX(in1[13],in2[4]) + MulFX(in1[14],in2[8]) + MulFX(in1[15],in2[12]);    
	out[13] = MulFX(in1[12],in2[1]) + MulFX(in1[13],in2[5]) + MulFX(in1[14],in2[9]) + MulFX(in1[15],in2[13]);    
	out[14] = MulFX(in1[12],in2[2]) + MulFX(in1[13],in2[6]) + MulFX(in1[14],in2[10]) + MulFX(in1[15],in2[14]);    
	out[15] = MulFX(in1[12],in2[3]) + MulFX(in1[13],in2[7]) + MulFX(in1[14],in2[11]) + MulFX(in1[15],in2[15]);
}

// intended to emulate glRotatex
__inline void rotate(GLfixed *curMtrx, GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
	if(!curMtrx) return;

	GLfixed m[16];

	const GLfixed c = f2x((float)cos(x2f(angle) * (3.14159f/180.0f)));
	const GLfixed s = f2x((float)sin(x2f(angle) * (3.14159f/180.0f)));
	const GLfixed mag = MulFX(x, x) + MulFX(y, y) + MulFX(z, z);

	// inverse sqrt to normalize
	// method from comp.graphics.algorithms
	float w = x2f(mag);
	float whalf = 0.5f*w;
	int i = *(int*)&w;
	i = 0x5f3759df - (i >> 1);
	w = *(float*)&i;
	w = w*(1.5f - whalf*w*w);
	
	GLfixed n = f2x(w);

	x = MulFX(x, n);
	y = MulFX(y, n);
	z = MulFX(z, n);

	m[0] = MulFX(x, MulFX(x, ONE_FX - c)) + c;	
	m[1] = MulFX(x, MulFX(y, ONE_FX-c)) + MulFX(z, s);
	m[2] = MulFX(z, MulFX(x, ONE_FX-c)) - MulFX(y, s);
	m[3] = 0;

	m[4] = MulFX(x, MulFX(y, ONE_FX-c)) - MulFX(z, s);
	m[5] = MulFX(y, MulFX(y, ONE_FX - c)) + c;
	m[6] = MulFX(y, MulFX(z, ONE_FX-c)) + MulFX(x, s);
	m[7] = 0;

	m[8] = MulFX(z, MulFX(x, ONE_FX-c)) + MulFX(y, s);
	m[9] = MulFX(y, MulFX(z, ONE_FX-c)) - MulFX(x, s);
	m[10] = MulFX(z, MulFX(z, ONE_FX - c)) + c;
	m[11] = 0;

	m[12] = 0;
	m[13] = 0;
	m[14] = 0;
	m[15] = ONE_FX;

	GLfixed out[16];

	matrixMultiply(m, curMtrx, out);

	for(int j = 0; j < 16; j++)
		curMtrx[j] = out[j];

	// load newly rotated matrix into OpenGL
	glLoadMatrixx(curMtrx);
}

// intended to emulate glTranslatex
__inline void translate(GLfixed *curMtrx, const GLfixed x, const GLfixed y, const GLfixed z)
{
	if(!curMtrx) return;

	GLfixed m[16];
	
	m[0] = ONE_FX;
	m[1] = 0;
	m[2] = 0;
	m[3] = 0;

	m[4] = 0;
	m[5] = ONE_FX;
	m[6] = 0;
	m[7] = 0;
	
	m[8] = 0;
	m[9] = 0;
	m[10] = ONE_FX;
	m[11] = 0;
	
	m[12] = x;
	m[13] = y;
	m[14] = z;
	m[15] = ONE_FX;

	GLfixed out[16];

	matrixMultiply(m, curMtrx, out);

	for(int i = 0; i < 16; i++)
		curMtrx[i] = out[i];

	// load newly translated matrix into OpenGL
	glLoadMatrixx(curMtrx);
}

// intended to emulate glFrustumx
__inline void frust(GLfixed *curMtrx, const GLfixed left, const GLfixed right, 
					  const GLfixed bottom, const GLfixed top, const GLfixed zNear, const GLfixed zFar)
{	
	if(!curMtrx) return;

	GLfixed m[16], out[16];

	// do not use fast directive on divides, precision is needed here
	m[0] = DivFX(MulFX(TWO_FX, zNear), right-left);
	m[1] = 0;
	m[2] = 0; 
	m[3] = 0;

	m[4] = 0;
	m[5] = DivFX(MulFX(TWO_FX, zNear), top-bottom);
	m[6] = 0;
	m[7] = 0;
		
	m[8] = DivFX(right+left, right-left);
	m[9] = DivFX(top+bottom, top-bottom);
	m[10] = DivFX(-(zFar+zNear), zFar-zNear);
	m[11] = -ONE_FX;
	
	m[12] = 0;
	m[13] = 0;
	m[14] = DivFX(-MulFX(MulFX(TWO_FX,zFar), zNear), zFar-zNear);
	m[15] = 0;

	matrixMultiply(m, curMtrx, out);

	for(int i = 0; i < 16; i++)
		curMtrx[i] = out[i];

	// load new matrix into OpenGL
	glLoadMatrixx(curMtrx);
}

// intended to emulate glOrthox
__inline void ortho(GLfixed *curMtrx, const GLfixed left, const GLfixed right, const GLfixed bottom, 
					const GLfixed top, const GLfixed zNear, const GLfixed zFar)
{
	if(!curMtrx) return;

	GLfixed m[16], out[16];

	// do not use fast directive on divides, precision is needed here
	m[0] = DivFX(TWO_FX, right - left);
	m[1] = 0;
	m[2] = 0;
	m[3] = 0;

	m[4] = 0;
	m[5] = DivFX(TWO_FX, top - bottom);
	m[6] = 0;
	m[7] = 0;
	
	m[8] = 0;
	m[9] = 0;
	m[10] = -DivFX(TWO_FX, zFar - zNear);
	m[11] = 0;
	
	m[12] = DivFX(-(right+left), right - left);
	m[13] = DivFX(-(top+bottom), top - bottom);
	m[14] = DivFX(-(zFar+zNear), zFar - zNear);
	m[15] = ONE_FX;

	matrixMultiply(m, curMtrx, out);

	for(int i = 0; i < 16; i++)
		curMtrx[i] = out[i];

	// load new matrix into OpenGL
	glLoadMatrixx(curMtrx);
}

#endif /* _WIN32_WCE */
// End Intel Corporation code